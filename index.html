<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Панквеб FTE Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- React & Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root{
      --app-header-h: 56px;
      --sheet-header-h: 44px;
      --left-col-w: 220px;
    }
    .hide-scrollbar::-webkit-scrollbar { display: none; }
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    
    /* Убираем горизонтальные скроллы */
    .no-horizontal-scroll {
      overflow-x: hidden;
    }
  </style>
</head>
<body class="bg-[#F7F8FA] no-horizontal-scroll">
  <div id="root"></div>

  <script type="text/babel">
    const {useState, useEffect, useMemo, useRef, Fragment} = React;

    // ---------- Config ----------
    const MAX_FTE = 1.2;
    const WEEK_COL_PX = 72;
    const TEAM_BAR_COLOR = "#22c55e";
    const VISIBLE_WEEKS = 16;

    // ---------- Persistence (local) ----------
    const LS_KEY = "fteplanner.v1";
    function loadJSON(key, fallback){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return fallback;
        const all = JSON.parse(raw);
        return (key in all) ? all[key] : fallback;
      }catch{ return fallback; }
    }
    function saveJSON(patch){
      try{
        const all = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
        const merged = {...all, ...patch};
        localStorage.setItem(LS_KEY, JSON.stringify(merged));
        debouncedSaveAllRemote(merged);
      }catch{}
    }

    // ---------- OPTIONAL: remote sync ----------
    async function loadAllRemote(){
      return null;
    }
    async function saveAllRemote(_state){
    }
    let saveTimer=null;
    function debouncedSaveAllRemote(state){
      clearTimeout(saveTimer);
      saveTimer = setTimeout(()=>{ saveAllRemote(state).catch(()=>{}); }, 400);
    }

    // ---------- Date/format helpers ----------
    const fmtISO = (date) => date.toISOString().slice(0,10);
    const addDays = (d, n) => { const x=new Date(d); x.setDate(x.getDate()+n); x.setHours(0,0,0,0); return x; };
    const pad2 = (n) => (n<10 ? `0${n}` : String(n));
    const fmtDM = (d) => `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}`;
    const RU_MONTHS = ["янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"];
    const ruMonthShort = (m) => RU_MONTHS[m] ?? "";
    const startOfISOWeek = (d) => { const day=d.getDay(); const diff=(day===0?-6:1)-day; const m=new Date(d); m.setDate(d.getDate()+diff); m.setHours(0,0,0,0); return m; };
    const addWeeks = (m, n) => { const d=new Date(m); d.setDate(d.getDate()+n*7); d.setHours(0,0,0,0); return d; };
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const scaleRatio = (v, max=MAX_FTE) => clamp(v/max, 0, 1);
    const weekLabelParts = (iso) => { const d=new Date(iso); const w=1+Math.floor((d.getDate()-1)/7); return { top:`${w} нед`, bot:ruMonthShort(d.getMonth()) }; };
    const weekRangeLabel = (iso) => { const d=new Date(iso); const end=addDays(d,6); return `${fmtDM(d)}—${fmtDM(end)}`; };
    const rndId = () => (globalThis.crypto && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
    const fmtFTE1 = (n) => (Math.round(n*10)/10).toFixed(1);
    const yearWeekMondays = (year) => { let m=startOfISOWeek(new Date(year,0,1)); const end=new Date(year,11,31); end.setHours(0,0,0,0); const list=[]; while(m<=end){ list.push(fmtISO(m)); m=addDays(m,7);} return list; };

    // ---------- Seed data ----------
    const base = startOfISOWeek(new Date());
    const initialWeeks = Array.from({length:24}, (_,i)=> fmtISO(addWeeks(base, i-4)));
    const seedPeople = [
      { id:"p1", name:"Саша", role:"manager", capacityPerWeek:1, active:true },
      { id:"p2", name:"Катя К.", role:"designer", capacityPerWeek:1, active:true },
    ];
    const seedProjects = [
      { id:"pr1", name:"HR Подкасты", status:"active", color:"#3b82f6" },
      { id:"pr2", name:"Арктика Медиа", status:"active", color:"#f43f5e" },
      { id:"pr3", name:"Падел-теннис", status:"planned", color:"#06b6d4" },
    ];
    const seedAssignments = [
      { id:"a1", personId:"p1", projectId:"pr1", weekStart: initialWeeks[4], fte:0.3 },
      { id:"a2", personId:"p1", projectId:"pr2", weekStart: initialWeeks[4], fte:0.2 },
      { id:"a3", personId:"p2", projectId:"pr2", weekStart: initialWeeks[5], fte:0.4 },
    ];
    const seedRoles = ["designer","dev","manager","pm","other"];

    // ---------- Aggregations ----------
    const personWeekTotal = (as, pid, w) => as.filter(a=>a.personId===pid && a.weekStart===w).reduce((s,a)=>s+a.fte,0);
    const fteFor = (as, pid, pr, w) => as.filter(a=>a.personId===pid && a.projectId===pr && a.weekStart===w).reduce((s,a)=>s+a.fte,0);
    const mergeOrder = (existing, nextIds) => {
      const seen=new Set(); const res=[];
      for(const id of (existing||[])) if(nextIds.includes(id) && !seen.has(id)){ res.push(id); seen.add(id); }
      for(const id of nextIds) if(!seen.has(id)){ res.push(id); seen.add(id); }
      return res;
    };

    // ---------- UI atoms ----------
    function StatusIcon({status}){
      const common = { width:16, height:16, viewBox:"0 0 24 24", fill:"white" };
      if(status==="active") return (<svg {...common}><polygon points="8,5 19,12 8,19"/></svg>);
      if(status==="onhold") return (<svg {...common}><rect x="6" y="5" width="4" height="14"/><rect x="14" y="5" width="4" height="14"/></svg>);
      if(status==="done") return (<svg {...common}><rect x="6" y="6" width="12" height="12" rx="2"/></svg>);
      return (<svg {...common}><circle cx="12" cy="12" r="6"/></svg>);
    }
    function MinusIcon({className=""}){
      return (
        <svg className={className} width="16" height="16" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
      );
    }
    function PencilIcon({className=""}){
      return (
        <svg className={className} width="14" height="14" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M12 20h9"/>
          <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4 12.5-12.5z"/>
        </svg>
      );
    }
    function TrashIcon({className=""}){
      return (
        <svg className={className} width="14" height="14" viewBox="0 0 24 24" fill="none"
             stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polyline points="3 6 5 6 21 6"/>
          <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
          <path d="M10 11v6"/>
          <path d="M14 11v6"/>
          <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/>
        </svg>
      );
    }
    function WeekHeader({iso}){
      const {top, bot} = weekLabelParts(iso);
      return (
        <div className="h-[40px] flex items-center justify-center text-neutral-700">
          <span className="block text-center leading-tight" style={{width:WEEK_COL_PX}}>
            <div className="text-xs font-medium">{top}</div>
            <div className="text-[10px]">{bot}</div>
          </span>
        </div>
      );
    }

    // ---------- Week navigator ----------
    function useWeeksWindow(){
      const [weeks, setWeeks] = useState(loadJSON("weeks", initialWeeks));
      const savedFirstISO = loadJSON("firstWeekISO", weeks[0]);
      const initIdx = Math.max(0, weeks.indexOf(savedFirstISO));
      const [firstIdx, setFirstIdx] = useState(initIdx);

      const ensureRange = (needIdx) => {
        if(needIdx < 0){
          const first = new Date(weeks[0]);
          const prepend = Array.from({length: Math.ceil((-needIdx)/8)*8 }, (_,i)=> fmtISO(addWeeks(first, -(i+1)))).reverse();
          const next = [...prepend, ...weeks];
          setWeeks(next);
          return { weeks: next, firstIdx: needIdx + prepend.length };
        }
        if(needIdx + VISIBLE_WEEKS >= weeks.length){
          const last = new Date(weeks[weeks.length-1]);
          const more = Array.from({length:16}, (_,i)=> fmtISO(addWeeks(last, i+1)));
          const next = [...weeks, ...more];
          setWeeks(next);
          return { weeks: next, firstIdx: needIdx };
        }
        return { weeks, firstIdx: needIdx };
      };

      const goLeft = () => {
        const {weeks: w2, firstIdx: f2} = ensureRange(firstIdx-1);
        setFirstIdx(f2); saveJSON({firstWeekISO: w2[f2]}); saveJSON({weeks: w2});
      };
      const goRight = () => {
        const {weeks: w2, firstIdx: f2} = ensureRange(firstIdx+1);
        setFirstIdx(f2); saveJSON({firstWeekISO: w2[f2]}); saveJSON({weeks: w2});
      };
      const goToday = () => {
        const todayISO = fmtISO(startOfISOWeek(new Date()));
        let idx = weeks.indexOf(todayISO);
        if(idx<0){
          let m = startOfISOWeek(new Date(todayISO));
          const end = addWeeks(m, 200);
          const set = new Set(weeks);
          const add = [];
          while(m<=end){ const iso=fmtISO(m); if(!set.has(iso)) add.push(iso); m = addDays(m,7); }
          const next = [...weeks, ...add].sort();
          setWeeks(next);
          idx = next.indexOf(todayISO);
          saveJSON({weeks: next});
        }
        const {weeks: w2, firstIdx: f2} = ensureRange(idx);
        setFirstIdx(f2); saveJSON({firstWeekISO: w2[f2]});
      };

      const visible = useMemo(()=> weeks.slice(firstIdx, firstIdx+VISIBLE_WEEKS), [weeks, firstIdx]);

      return {weeks, setWeeks, firstIdx, setFirstIdx, visible, goLeft, goRight, goToday};
    }

    // =================================
    // App
    // =================================
    function App(){
      const [people, setPeople] = useState(loadJSON("people", seedPeople));
      const [projects, setProjects] = useState(loadJSON("projects", seedProjects));
      const [assignments, setAssignments] = useState(loadJSON("assignments", seedAssignments));
      const [roles, setRoles] = useState(loadJSON("roles",[...seedRoles]));
      const [projectTeams, setProjectTeams] = useState(()=>{
        const saved = loadJSON("projectTeams", {});
        const map = {};
        Object.keys(saved).forEach(k => (map[k]=new Set(saved[k])));
        if(Object.keys(map).length===0){
          for(const p of seedProjects) map[p.id]=new Set();
          for(const a of seedAssignments) (map[a.projectId] = map[a.projectId] || new Set()).add(a.personId);
        }
        return map;
      });
      const [vacations, setVacations] = useState(()=>{
        const saved = loadJSON("vacations", {});
        const map = {}; Object.keys(saved).forEach(k => (map[k] = new Set(saved[k])));
        return map;
      });
      const [personProjectOrder, setPersonProjectOrder] = useState(loadJSON("personProjectOrder", {}));
      const [teamOrder, setTeamOrder] = useState(()=> loadJSON("teamOrder", seedPeople.map(p=>p.id)));

      const [authed, setAuthed] = useState(loadJSON("authed", false));
      const [view, setView] = useState("team");
      const [selectedPersonId, setSelectedPersonId] = useState(null);

      const {weeks, setWeeks, visible, goLeft, goRight, goToday} = useWeeksWindow();

      useEffect(()=>{
        (async()=>{
          const remote = await loadAllRemote();
          if(remote && typeof remote==="object"){
            localStorage.setItem(LS_KEY, JSON.stringify(remote));
            if(remote.people) setPeople(remote.people);
            if(remote.projects) setProjects(remote.projects);
            if(remote.assignments) setAssignments(remote.assignments);
            if(remote.roles) setRoles(remote.roles);
            if(remote.projectTeams){
              const map={}; Object.entries(remote.projectTeams).forEach(([k,v])=> map[k]=new Set(v));
              setProjectTeams(map);
            }
            if(remote.vacations){
              const map={}; Object.entries(remote.vacations).forEach(([k,v])=> map[k]=new Set(v));
              setVacations(map);
            }
            if(remote.personProjectOrder) setPersonProjectOrder(remote.personProjectOrder);
            if(remote.teamOrder) setTeamOrder(remote.teamOrder);
            if(remote.weeks) setWeeks(remote.weeks);
          }
        })().catch(()=>{});
      }, []);

      // ---- persistence ----
      useEffect(()=> saveJSON({people}), [people]);
      useEffect(()=> saveJSON({projects}), [projects]);
      useEffect(()=> saveJSON({assignments}), [assignments]);
      useEffect(()=> saveJSON({roles}), [roles]);
      useEffect(()=>{ const obj={}; Object.entries(projectTeams).forEach(([k,v])=> obj[k]=Array.from(v)); saveJSON({projectTeams:obj}); }, [projectTeams]);
      useEffect(()=>{ const obj={}; Object.entries(vacations).forEach(([k,v])=> obj[k]=Array.from(v)); saveJSON({vacations:obj}); }, [vacations]);
      useEffect(()=> saveJSON({personProjectOrder}), [personProjectOrder]);
      useEffect(()=> saveJSON({teamOrder}), [teamOrder]);

      // ---- derived ----
      const isVacation = (pid,w) => !!vacations[pid]?.has?.(w);
      const dragRow = useRef(null);
      useEffect(()=> setTeamOrder(prev => mergeOrder(prev, people.map(p=>p.id))), [people]);
      const activePeople = useMemo(()=> people.filter(p=>p.active), [people]);

      // фильтр ролей
      const [roleFilter, setRoleFilter] = useState(loadJSON("roleFilter","all"));
      useEffect(()=> saveJSON({roleFilter}), [roleFilter]);

      const activeTeamIds = useMemo(()=> teamOrder.filter(id => activePeople.some(p=>p.id===id)), [teamOrder, activePeople]);
      const filteredTeamIds = useMemo(()=> activeTeamIds.filter(id => roleFilter==="all" ? true : (people.find(p=>p.id===id)?.role===roleFilter)), [activeTeamIds, roleFilter, people]);

      // ---- helpers ----
      function deletePerson(pid){
        if(!confirm("Удалить сотрудника?")) return;
        setPeople(prev => prev.filter(p=>p.id!==pid));
        setAssignments(prev => prev.filter(a=>a.personId!==pid));
        setVacations(prev => { const c={}; Object.entries(prev).forEach(([k,v])=>{ if(k!==pid) c[k]=new Set(v); }); return c; });
        setProjectTeams(prev => { const c={}; Object.entries(prev).forEach(([k,v])=>{ const s=new Set(v); s.delete(pid); c[k]=s; }); return c; });
        setTeamOrder(prev => prev.filter(id=>id!==pid));
      }
      function deleteProject(prid){
        if(!confirm("Удалить проект?")) return;
        setProjects(prev => prev.filter(p=>p.id!==prid));
        setAssignments(prev => prev.filter(a=>a.projectId!==prid));
        setProjectTeams(prev => { const c={}; Object.entries(prev).forEach(([k,v])=>{ if(k!==prid) c[k]=new Set(v); }); return c; });
        setPersonProjectOrder(prev => { const out={}; Object.entries(prev).forEach(([pid, arr]) => { out[pid]=(arr||[]).filter(x=>x!==prid); }); return out; });
      }

      // DnD projects
      const dragProjectIndex = useRef(null);
      const onProjectDragStart = (i) => { dragProjectIndex.current = i; };
      const onProjectDrop = (i) => {
        const from = dragProjectIndex.current;
        dragProjectIndex.current = null;
        if(from==null || from===i) return;
        setProjects(prev => {
          const arr = [...prev];
          const [moved] = arr.splice(from,1);
          arr.splice(i,0,moved);
          return arr;
        });
      };

      // person form (modal)
      const [createPersonOpen, setCreatePersonOpen] = useState(false);
      const [newPersonName, setNewPersonName] = useState("");
      const [newPersonRole, setNewPersonRole] = useState("other");
      function submitNewPerson(){
        const name = newPersonName.trim(); if(!name) return;
        const id = rndId();
        setPeople(p => [...p, { id, name, role:newPersonRole||"other", capacityPerWeek:1, active:true }]);
        setCreatePersonOpen(false); setNewPersonName(""); setNewPersonRole("other");
      }

      // project form (modal)
      const [createProjectOpen, setCreateProjectOpen] = useState(false);
      const [newProjectName, setNewProjectName] = useState("");
      const [newProjectColor, setNewProjectColor] = useState("#3b82f6");
      const [newProjectStatus, setNewProjectStatus] = useState("active");
      const [projSearch, setProjSearch] = useState("");
      const [projTeamSel, setProjTeamSel] = useState(()=> new Set());
      const personSuggestions = useMemo(()=> activePeople.filter(p => p.name.toLowerCase().includes(projSearch.toLowerCase()) && !projTeamSel.has(p.id)).slice(0,6), [activePeople, projSearch, projTeamSel]);
      function submitNewProject(){
        const name = newProjectName.trim(); if(!name) return;
        const id = rndId(); const color = newProjectColor || "#64748b"; const status = newProjectStatus;
        setProjects(ps => [...ps, { id, name, color, status }]);
        setProjectTeams(pt => { const copy={}; Object.entries(pt).forEach(([k,v])=>copy[k]=new Set(v)); copy[id]=new Set(projTeamSel); return copy; });
        setCreateProjectOpen(false); setNewProjectName(""); setProjSearch(""); setProjTeamSel(new Set()); setNewProjectStatus("active"); setView("project");
      }

      // ============== AUTH ==============
      if(!authed){
        return (
          <div className="min-h-screen grid place-items-center bg-[#F7F8FA]">
            <div className="bg-white w-[360px] rounded-2xl shadow-lg border border-neutral-200 p-5">
              <div className="text-center mb-4"><div className="text-2xl font-semibold">Вход</div></div>
              <AuthForm onSuccess={(remember)=>{ if(remember){ saveJSON({authed:true, remember:true}); } else { saveJSON({remember:false, authed:false}); } setAuthed(true); }} />
            </div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-[#F7F8FA] text-neutral-900 font-sans no-horizontal-scroll">
          {/* Глобальная шапка - всегда липкая */}
          <header className="sticky top-0 z-50 border-b border-neutral-200 bg-white/90 backdrop-blur" style={{height:'var(--app-header-h)'}}>
            <div className="max-w-screen-2xl mx-auto px-4 h-full flex items-center gap-3">
              <div className="text-lg font-semibold tracking-tight text-green-600">Панквеб FTE Planner</div>
              <div className="ml-4 flex items-center gap-1 bg-neutral-100 border border-neutral-200 rounded-2xl p-1 shadow-sm">
                <button className={`px-3 py-1 rounded-xl transition ${view==="team" ? "bg-white shadow-sm" : "hover:bg-white/70"}`} onClick={()=>setView("team")}>Команда</button>
                <button className={`px-3 py-1 rounded-xl transition ${view==="project" ? "bg-white shadow-sm" : "hover:bg-white/70"}`} onClick={()=>setView("project")}>Проекты</button>
              </div>
              <div className="ml-auto flex items-center gap-2">
                <button onClick={()=>setCreateProjectOpen(true)} className="rounded-xl border border-neutral-300 px-3 py-1 bg-white shadow-sm hover:shadow transition">+ Проект</button>
                <button onClick={()=>setCreatePersonOpen(true)} className="rounded-xl border border-neutral-300 px-3 py-1 bg-white shadow-sm hover:shadow transition">+ Сотрудник</button>
              </div>
            </div>
          </header>

          <main className="max-w-screen-2xl mx-auto p-4">
            {view==="team" ? (
              <>
                {/* Навигатор недель + фильтр ролей - на одном уровне */}
                <div className="sticky z-40 bg-[#F7F8FA] pt-2 pb-3" style={{top:'var(--app-header-h)'}}>
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-3">
                      <label className="text-sm text-neutral-700">Фильтр роли</label>
                      <select className="border border-neutral-300 rounded-xl px-2 py-1 text-sm" value={roleFilter} onChange={e=>setRoleFilter(e.target.value)}>
                        <option value="all">Все</option>
                        {roles.map(r => (<option key={r} value={r}>{r}</option>))}
                      </select>
                    </div>
                    <div className="flex items-center gap-2">
                      <button onClick={goLeft} className="px-2 py-1 rounded-lg border border-neutral-300 bg-white hover:shadow" title="Назад на неделю">‹</button>
                      <button onClick={goToday} className="px-2 py-1 rounded-lg border border-neutral-300 bg-white hover:shadow" title="Показать текущую неделю">Сегодня</button>
                      <button onClick={goRight} className="px-2 py-1 rounded-lg border border-neutral-300 bg-white hover:shadow" title="Вперёд на неделю">›</button>
                    </div>
                  </div>
                </div>

                {/* Сетка: лево — sticky плашка, справа — строго VISIBLE_WEEKS колонок (без горизонтального скролла) */}
                <div className="grid" style={{gridTemplateColumns:`var(--left-col-w) repeat(${visible.length}, ${WEEK_COL_PX}px)`}}>
                  <div className="sticky left-0 z-50 bg-[#F7F8FA] backdrop-blur border-r border-neutral-200 p-2 text-sm font-medium" />
                  {visible.map(w => (<div key={w} className="border-b border-neutral-200"><WeekHeader iso={w}/></div>))}
                  {filteredTeamIds.map((pid, rowIdx) => {
                    const person = people.find(p=>p.id===pid);
                    return (
                      <Fragment key={pid}>
                        <div
                          className="sticky left-0 z-50 bg-[#F7F8FA] backdrop-blur border-r border-neutral-200 p-1"
                          draggable
                          onDragStart={()=>{ dragRow.current=rowIdx; }}
                          onDragOver={e=>e.preventDefault()}
                          onDrop={()=>{
                            const from=dragRow.current; const to=rowIdx; if(from==null || from===to) return;
                            const arr=[...filteredTeamIds]; const id=arr.splice(from,1)[0]; arr.splice(to,0,id);
                            const inactive = teamOrder.filter(id => !filteredTeamIds.includes(id));
                            setTeamOrder([...arr, ...inactive]); dragRow.current=null;
                          }}
                        >
                          <div
                            role="button"
                            tabIndex={0}
                            onClick={()=>setSelectedPersonId(person.id)}
                            onKeyDown={e=>{ if(e.key==='Enter'||e.key===' ') setSelectedPersonId(person.id) }}
                            className="w-full text-left"
                          >
                            <div className="relative bg-white rounded-2xl shadow-sm h-[120px] flex flex-col justify-center pl-5 pr-8 hover:shadow-md hover:bg-blue-50/70 transition">
                              <div className="font-medium truncate" title="Открыть карточку сотрудника">{person.name}</div>
                              <div className="mt-1 text-[11px] text-neutral-600">{String(person.role||"").toUpperCase()}</div>
                              <button
                                type="button"
                                draggable={false}
                                aria-label="Удалить сотрудника"
                                onMouseDown={(e)=>e.preventDefault()}
                                onClick={(e)=>{ e.stopPropagation(); deletePerson(person.id); }}
                                title="Удалить"
                                className="absolute top-2 right-2 w
